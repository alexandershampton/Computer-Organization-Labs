.ORIG x3000
;	Your main() function starts here
BEGINNING
LD R6, STACK_PTR; (R6 = x5013)
ADD R6, R6, #-1; (R6 = X5012)
ADD R5, R6, #0; (R5 = X5012)
LEA R4, GLOBAL_VARS; POINTS R4 AT THE GLOBAL VARIABLES
LEA R0, PROMPT0; LOADS PROMPT INTO R0
PUTS; OUTPUTS R0
GETC; GETS CHARACTER INPUT FROM USER
OUT; OUTPUTS CHARACTER 

LD R1, NUMERIC_VAL
NOT R1, R1
ADD R1, R1, #1
ADD R0, R1, R0
ADD R1, R0, #0
STR R0, R6, #0; (R6 @ X5012)
ADD R6, R6, #-1; (R6 = X5011)
JSR FIBONACCI

LDR R2, R5, #-1; (R5 @ X5011)
LEA R0, PROMPT1
PUTS
ADD R0, R1, #0
LD R1, ASCII_NUM
NOT R1, R1
ADD R1, R1, #1
ADD R0, R0, R1
OUT

LEA R0, PROMPT2
PUTS
ADD R3, R2, #0
AND R1, R1, #0

CHECK_10S
ADD R1, R1, #1
ADD R3, R3, #-10
BRzp CHECK_10S
ADD R1, R1, #-1
BRz SKIP_PRINT10S
ADD R0, R1, #0
LD R1, ASCII_NUM
NOT R1, R1
ADD R1, R1, #1
ADD R0, R1, R0
OUT

SKIP_PRINT10S
ADD R3, R3, #10
AND R1, R1, #0

CHECK_1S
ADD R1, R1, #1
ADD R3, R3, #-1
BRzp CHECK_1S
ADD R1, R1, #-1
ADD R0, R1, #0
LD R1, ASCII_NUM
NOT R1, R1
ADD R1, R1, #1
ADD R0, R1, R0
OUT
;
LEA R0, PROMPT3
PUTS
STR R2, R5, #1; (R5 = X5013) 
ADD R6, R6, #1; (R6 = X5014)
BRnzp BEGINNING
HALT

GLOBAL_VARS					;	Your global variables start here
PROMPT0 		.STRINGz	"Please enter a number n: ";	The first prompt to print
STACK_PTR		.FILL x5013	;	STACK_PTR is a pointer to the bottom of the stack	(x5013)
ASCII_NUM		.FILL #-48	;	Helpful for printing ASCII numbers
PROMPT1 		.STRINGz	"\nF(";	The second prompt
PROMPT2 		.STRINGz	") = ";	The second prompt
PROMPT3			.STRINGz	"\n"
NUMERIC_VAL              .FILL x0030	    ; HEX value of the start of numeric HEX digits (0 - 9)

FIBONACCI
;	Your fibonacci subroutine starts here
ADD R6, R6, #-1; (R6 = X5010), (R6 = X5008)
STR R7, R6, #0; 
ADD R6, R6, #-1; (R6 = X500F), (R6 = X5007)
STR R5, R6, #0
ADD R6, R6, #-1; (R6 = X500E), (R6 = X5006)
STR R3, R6, #0
ADD R6, R6, #-1; (R6 = X500D), (R6 = X5005)
STR R2, R6, #0
ADD R6, R6, #-1; (R6 = X500C), (R6 = X5004)
STR R1, R6, #0
ADD R6, R6, #-1; (R6 = X500B), (R6 = X5003)
STR R0, R6, #0
ADD R6, R6, #-1; (R6 = X500A), (R6 = X5002)
ADD R5, R6, #0; (R5 = X500A), (R5 = X5002)
;
;IF N == 1
LDR R0, R5, #8; (R5 @ X5012), (R5 = X500A)
AND R1, R1, #0
ADD R1, R1, #1
NOT R1, R1
ADD R1, R1, #1
ADD R1, R0, R1; CHECKS IF R0 == 1
BRz END_ALL_CASES
;IF N == 0
ADD R0, R0, #1; ADDS ONE TO R0
AND R1, R1, #0
ADD R1, R1, #1
NOT R1, R1
ADD R1, R1, #1; 2'S COMPLEMENT OF 1
ADD R0, R1, R0; CHECKS IF R0 == 0
BRz END_ALL_CASES
;
;CALCULATE N-1
ADD R0, R0, #-1; INPUT FOR N-1
STR R0, R6, #0; (R6 @ X500A)
ADD R6, R6, #-1; (R6 = X5009)
JSR FIBONACCI
LDR R1, R5, #-1; (R5 @ X5009)
ADD R6, R6, #-1; (R6 = X500A)
;
;CALCULATE N-2
ADD R0, R0, #-1; INPUT FOR N-2
STR R0, R6, #0; (R6 @ X500A)
ADD R6, R6, #-1; (R6 = X5009)
JSR FIBONACCI
LDR R2, R5, #-1; (R5 @ X5009)
ADD R6, R6, #-1; (R6 = X500A)
ADD R0, R1, R2; ADDS RETURN VALUES TOGETHER
;
END_ALL_CASES
STR R0, R5, #7; (R5 @ X5011), (R5 @ 5009)
ADD R6, R6, #1; (R6 = X500B), (R6 = X5003)
LDR R0, R6, #0
ADD R6, R6, #1; (R6 = X500C), (R6 = X5004)
LDR R1, R6, #0
ADD R6, R6, #1; (R6 = X500D), (R6 = X5005)
LDR R2, R6, #0
ADD R6, R6, #1; (R6 = X500E), (R6 = X5006)
LDR R3, R6, #0
ADD R6, R6, #1; (R6 = X500F), (R6 = X5007)
LDR R5, R6, #0
ADD R6, R6, #1; (R6 = X5010), (R6 = X5008)
LDR R7, R6, #0
ADD R6, R6, #1; (R6 = X5011), (R6 = X5009)
ADD R6, R6, #1; (R6 = X5012), (R6 = X500A)
ADD R6, R6, #1; (R6 = X5013), (R6 = X500B)
RET

.END